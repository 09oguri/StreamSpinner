/*
 * Copyright 2005-2009 StreamSpinner Project
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Generated By:JavaCC: Do not edit this line. InnerParser.java */
package org.streamspinner.harmonica.query.hamql;

import org.streamspinner.*;
import org.streamspinner.engine.*;
import org.streamspinner.query.*;
import org.streamspinner.harmonica.*;
import org.streamspinner.harmonica.query.*;

import java.io.*;
import java.util.*;
import java.text.*;

/**
 * 内部パーサー．
 * @author snic
 * @version 1.0 (2006.7.26)
 */
public class InnerParser implements InnerParserConstants {
        private HamQLQuery hamql = null;

        public InnerParser(String hamql_statement){
                this(new BufferedReader(new StringReader(hamql_statement)));

                hamql = new HamQLQuery();
        }

        /**
	 * 解析して抽出されたHamQLQueryオブジェクトを取得する．
	 *
	 * @return HamQLQueryオブジェクト
	 */
        public HamQLQuery getQuery(){
                return hamql;
        }

        private void debug(Object o){
                HarmonicaManager.debug("InnerParser",o);
        }

  final public void parse() throws ParseException, HarmonicaException {
        if(hamql == null) throw new HarmonicaException("Invalid initialize!");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
      create_table();
                                {if (true) return;}
      break;
    case DROP:
      drop_table();
                              {if (true) return;}
      break;
    case MASTER:
    case SELECT:
    case INSERT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MASTER:
        master();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INSERT:
        insert_start();
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
      query();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNION:
        union();
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
                 {if (true) return;}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void query() throws ParseException {
    select();
    from();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      where();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUP:
      group();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
  }

  final public void union() throws ParseException {
        HamQLQuery union_query = new HamQLQuery();
        boolean is_union_all = false;
    jj_consume_token(UNION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
      jj_consume_token(ALL);
               is_union_all = true;
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    hamql_query(union_query);
                union_query.setUnionAll(is_union_all);
                hamql.addUnion(union_query);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNION:
      union();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
  }

// ---------- DROP節 ---------- //
  final public void drop_table() throws ParseException {
        Token t1 = null;
    jj_consume_token(DROP);
    jj_consume_token(TABLE);
    t1 = jj_consume_token(WORD);
                hamql.setDropClause(t1.image);
  }

// ---------- CREATE節 ---------- //
  final public void create_table() throws ParseException {
        Token t1 = null;
        Schema schema = null;
        Vector<String> names = new Vector<String>();
        Vector<String> types = new Vector<String>();
        String table = null;
    jj_consume_token(CREATE);
    jj_consume_token(TABLE);
    t1 = jj_consume_token(WORD);
                table = t1.image;
    jj_consume_token(LK);
    table_attr_list(table,names,types);
                schema = new Schema
                        (table,
                         names.toArray(new String[0]),
                         types.toArray(new String[0])
                        );
                hamql.setCreateClause(schema);
  }

  final public void table_attr_list(String table, Vector<String> names, Vector<String> types) throws ParseException {
    table_attr_element(table, names, types);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONNMA:
      jj_consume_token(CONNMA);
      table_attr_list(table, names, types);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
  }

  final public void table_attr_element(String table, Vector<String> names, Vector<String> types) throws ParseException {
    table_attr_element_name(table, names);
    table_attr_element_type(types);
  }

  final public void table_attr_element_name(String table, Vector<String> names) throws ParseException {
        Token t1 = null;
        Token t2 = null;
    t1 = jj_consume_token(WORD);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      t2 = jj_consume_token(WORD);
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
                if(t2 == null){
                        names.add(table+"."+t1.image);
                }else{
                        names.add(t1.image+"."+t2.image);
                }
  }

  final public void table_attr_element_type(Vector<String> types) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      jj_consume_token(STRING);
                        types.add(DataTypes.STRING);
      break;
    case LONG:
      jj_consume_token(LONG);
                        types.add(DataTypes.LONG);
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
                        types.add(DataTypes.DOUBLE);
      break;
    case OBJECT:
      jj_consume_token(OBJECT);
                        types.add(DataTypes.OBJECT);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// ---------- INSERT節 ---------- //
  final public void insert_start() throws ParseException {
        Token t1 = null;
        Schema schema = null;
        String[] names = new String[0];
        String[] types = new String[0];
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    t1 = jj_consume_token(WORD);
                schema = new Schema(t1.image, names, types);
                hamql.setInsertClause(schema);
  }

// ---------- MASTER節 ---------- //
  final public void master() throws ParseException {
        MasterSet masters = new MasterSet();
    jj_consume_token(MASTER);
    master_list(masters);
                hamql.setMasterClause(masters);
  }

  final public void master_list(MasterSet masters) throws ParseException {
    master_source(masters);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONNMA:
      jj_consume_token(CONNMA);
      master_list(masters);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
  }

  final public void master_source(MasterSet masters) throws ParseException {
        Token t = null;
    t = jj_consume_token(WORD);
                masters.add(t.image);
  }

// ---------- SELECT節 ---------- //
  final public void select() throws ParseException {
        AttributeList attrs = new AttributeList();
    jj_consume_token(SELECT);
    attribute_list(attrs);
                hamql.setSelectClause(attrs);
  }

  final public void attribute_list(AttributeList attrs) throws ParseException {
        Token t1 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTER:
      jj_consume_token(ASTER);
                        attrs.add("*");
      break;
    case WORD:
      attribute_element(attrs);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONNMA:
        jj_consume_token(CONNMA);
        attribute_list(attrs);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void attribute_element(AttributeList attrs) throws ParseException {
        Token t1 = null;
    t1 = jj_consume_token(WORD);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LK:
      function_attribute(t1.image, attrs);
      break;
    default:
      jj_la1[14] = jj_gen;
      attribute(t1.image, attrs);
    }
  }

  final public void attribute(String name, AttributeList attrs) throws ParseException {
        Token t1 = null;
        Token t2 = null;
        HarmonicaAttribute attr = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTER:
        t1 = jj_consume_token(ASTER);
        break;
      case WORD:
        t1 = jj_consume_token(WORD);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      t2 = jj_consume_token(WORD);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
                if(t1!=null){
                        attr = new HarmonicaAttribute(name,t1.image);
                }else{
                        attr = new HarmonicaAttribute("",name);
                }
                if(t2 != null){
                        attr.setRename(t2.image);
                }
                attrs.add(attr);
  }

  final public void function_attribute(String fname, AttributeList attrs) throws ParseException {
        Token t1 = null;
        HarmonicaFunctionParameter function = null;
        AttributeList attrs2 = new AttributeList();
    jj_consume_token(LK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTER:
    case WORD:
      attribute_list(attrs2);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(RK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      t1 = jj_consume_token(WORD);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
                function = new HarmonicaFunctionParameter(fname, attrs2);
                if(t1 != null){
                        function.setRename(t1.image);
                }
                attrs.add(function);
  }

// ---------- FROM節 ---------- //
  final public void from() throws ParseException {
        HarmonicaSourceSet sources = new HarmonicaSourceSet();
    jj_consume_token(FROM);
    from_list(sources);
                hamql.setFromClause(sources);
  }

  final public void from_list(HarmonicaSourceSet sources) throws ParseException {
    from_element(sources);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONNMA:
      jj_consume_token(CONNMA);
      from_list(sources);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
  }

  final public void from_element(HarmonicaSourceSet sources) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      source(sources);
      break;
    case LK:
      sub_query(sources);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void source(HarmonicaSourceSet sources) throws ParseException {
        Token t1 = null;
        Token t2 = null;
        HarmonicaSource source = new HarmonicaSource();
        source.setType(SourceType.SOURCE);
    t1 = jj_consume_token(WORD);
                source.setSource(t1.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KLK:
      window(source);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
                sources.add(source);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      t2 = jj_consume_token(WORD);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
                if(t2 != null) source.setRename(t2.image);
  }

  final public void window(HarmonicaSource source) throws ParseException {
        Token t1 = null;
    jj_consume_token(KLK);
    t1 = jj_consume_token(INTEGER_VALUE);
                source.setWindowSize(Long.parseLong(t1.image));
                //source.setSliding(true);
                source.setSliding(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONNMA:
      jj_consume_token(CONNMA);
      window_at(source);
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    jj_consume_token(KRK);
  }

  final public void window_at(HarmonicaSource source) throws ParseException {
        Token t1 = null;
        long l = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOW:
      jj_consume_token(NOW);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        jj_consume_token(MINUS);
        t1 = jj_consume_token(INTEGER_VALUE);
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
                                if(t1 != null){
                                        source.setOriginalTime(Long.parseLong(t1.image)*(-1));
                                }else{
                                        source.setOriginalTime(0);
                                }
      break;
    case INTEGER_VALUE:
      t1 = jj_consume_token(INTEGER_VALUE);
                                source.setOriginalTime(Long.parseLong(t1.image));
      break;
    case TIME:
      // data convert to time
                      l = time_function();
                                source.setOriginalTime(l);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                source.setSliding(false);
                debug(source.getOriginalTime());
  }

  final public long time_function() throws ParseException {
        long l = 0;
    jj_consume_token(TIME);
    jj_consume_token(LK);
    l = time_function_arg();
    jj_consume_token(RK);
                {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public long time_function_arg() throws ParseException {
        long l = 0;
        Token t = null;
    t = jj_consume_token(DATE_WORDS);
                debug(t.image);
                SimpleDateFormat df = null;

                Date d = null;
                try{
                        df = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss.SSS");
                        d = df.parse(t.image);
                }catch(java.text.ParseException e){}

                if(d == null){
                        try{
                                df = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
                                d = df.parse(t.image);
                        }catch(java.text.ParseException e){}
                }

                if(d == null){
                        try{
                                df = new SimpleDateFormat("yyyy/MM/dd HH:mm");
                                d = df.parse(t.image);
                        }catch(java.text.ParseException e){}
                }

                if(d == null)
                        {if (true) throw new org.streamspinner.harmonica.query.hamql.ParseException
                                ("Format is yyyy/MM/dd HH:mm:ss.SSS");}

                l = d.getTime();
                {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public double prm_expr() throws ParseException {
        double l = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_VALUE:
    case DOUBLE_VALUE:
      l = number();
      break;
    case LK:
      jj_consume_token(LK);
      l = add_expr();
      jj_consume_token(RK);
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public double add_expr() throws ParseException {
        double l = 0, r = 0;
        Token t = null;
    l = mul_expr();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      r = mul_expr();
                        l = (t.kind == PLUS) ? l+r : l-r;
    }
                {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public double mul_expr() throws ParseException {
        double l = 0, r = 0;
        Token t = null;
    l = prm_expr();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIV:
      case ASTER:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTER:
        t = jj_consume_token(ASTER);
        break;
      case DIV:
        t = jj_consume_token(DIV);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      r = prm_expr();
                        if(t.kind == ASTER){
                                l = l*r;
                        }else{
                                if(r == 0)
                                        {if (true) throw new org.streamspinner.harmonica.query.hamql.ParseException("Can't calucurate n/0");}
                                l = l/r;
                        }
    }
                {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public void sub_query(HarmonicaSourceSet sources) throws ParseException {
        HarmonicaSource source = new HarmonicaSource();
        source.setType(SourceType.SUB_QUERY);
        HamQLQuery sub_hamql = new HamQLQuery();
        Token t1 = null;
    jj_consume_token(LK);
    hamql_query(sub_hamql);
    jj_consume_token(RK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      t1 = jj_consume_token(WORD);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
                source.setQuery(sub_hamql);
                sources.add(source);
                if(t1 != null) source.setRename(t1.image);
  }

  final public void hamql_query(HamQLQuery sub_hamql) throws ParseException {
        HamQLQuery tmp = hamql;
        hamql = sub_hamql;
    query();
                hamql = tmp;
  }

// ---------- WHERE節 ---------- //
  final public void where() throws ParseException {
        PredicateSet conditions = new PredicateSet();
    jj_consume_token(WHERE);
    where_list(conditions);
                hamql.setWhereClause(conditions);
  }

  final public void where_list(PredicateSet conditions) throws ParseException {
    where_element(conditions);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
      jj_consume_token(AND);
      where_list(conditions);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
  }

  final public void where_element(PredicateSet conditions) throws ParseException {
        Predicate cond = null;
        String left = null;
        String right = null;
        String op = null;
        Token t1 = null;
    left = where_element_part();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
      t1 = jj_consume_token(EQ);
      break;
    case GE:
      t1 = jj_consume_token(GE);
      break;
    case GT:
      t1 = jj_consume_token(GT);
      break;
    case LE:
      t1 = jj_consume_token(LE);
      break;
    case LT:
      t1 = jj_consume_token(LT);
      break;
    case NE:
      t1 = jj_consume_token(NE);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    right = where_element_part();
                if(t1.image.equals("=")){ op = Predicate.EQ; }
                else if(t1.image.equals(">=")){ op = Predicate.GE; }
                else if(t1.image.equals(">")){ op = Predicate.GT; }
                else if(t1.image.equals("<=")){ op = Predicate.LE; }
                else if(t1.image.equals("<")){ op = Predicate.LT; }
                else { op = Predicate.NE; }

                cond = new Predicate(left, op, right);
                conditions.add(cond);
  }

  final public String where_element_part() throws ParseException {
        String part = "";
        Token t1 = null;
        Token t2 = null;
        double d = 0.0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      t1 = jj_consume_token(WORD);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LK:
        jj_consume_token(LK);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WORD:
          part = args();
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
        }
        jj_consume_token(RK);
                                                {if (true) return t1.image+"("+part+")";}
        break;
      default:
        jj_la1[37] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
          t2 = jj_consume_token(WORD);
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
                                if(t2 != null) {if (true) return t1.image + "." + t2.image;}
                                {if (true) return t1.image;}
      }
      break;
    case WORDS:
      t1 = jj_consume_token(WORDS);
                             {if (true) return t1.image;}
      break;
    case LK:
    case INTEGER_VALUE:
    case DOUBLE_VALUE:
      d = add_expr();
                              {if (true) return Double.toString(d);}
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String args() throws ParseException {
        String part1 = null;
        String part2 = null;
    part1 = arg();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONNMA:
      jj_consume_token(CONNMA);
      part2 = args();
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
                if(part2 != null) {if (true) return part1 + "," + part2;}
                {if (true) return part1;}
    throw new Error("Missing return statement in function");
  }

  final public String arg() throws ParseException {
        Token t1 = null;
        Token t2 = null;
    t1 = jj_consume_token(WORD);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      t2 = jj_consume_token(WORD);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
                if(t2 != null) {if (true) return t1.image + "." + t2.image;}
                {if (true) return t1.image;}
    throw new Error("Missing return statement in function");
  }

  final public double number() throws ParseException {
        Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_VALUE:
      t = jj_consume_token(INTEGER_VALUE);
      break;
    case DOUBLE_VALUE:
      t = jj_consume_token(DOUBLE_VALUE);
      break;
    default:
      jj_la1[41] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return Double.parseDouble(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public double exp() throws ParseException {
        double n = 0.0;
        double d = 0.0;
        Token t = null;
    n = number();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case DIV:
    case ASTER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      case ASTER:
        t = jj_consume_token(ASTER);
        break;
      case DIV:
        t = jj_consume_token(DIV);
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      d = exp();
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
                if(t == null) {if (true) return n;}
                switch(t.kind){
                        case PLUS:
                                {if (true) return n+d;}
                        case MINUS:
                                {if (true) return n-d;}
                        case ASTER:
                                {if (true) return n*d;}
                        case DIV:
                                {if (true) return n/d;}
                        default:
                                {if (true) return 0.0;}
                }
    throw new Error("Missing return statement in function");
  }

// ---------- GROUP節 ---------- //
  final public void group() throws ParseException {
        AttributeList groups = new AttributeList();
    jj_consume_token(GROUP);
    jj_consume_token(BY);
    group_list(groups);
                hamql.setGroupClause(groups);
  }

  final public void group_list(AttributeList groups) throws ParseException {
    group_element(groups);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONNMA:
      jj_consume_token(CONNMA);
      group_list(groups);
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
  }

  final public void group_element(AttributeList groups) throws ParseException {
        Attribute group = null;
        Token t1 = null;
        Token t2 = null;
    t1 = jj_consume_token(WORD);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      t2 = jj_consume_token(WORD);
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
                if(t2 != null) group = new Attribute(t1.image, t2.image);
                else group = new Attribute("", t1.image);

                groups.add(group);
  }

  public InnerParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[46];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x20,0x80000,0x4000,0x2a0060,0x100,0x400,0x8000,0x4000,0x0,0x0,0x3c00000,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x1000,0x0,0x0,0x0,0x1000,0x0,0x0,0x12000,0x0,0x0,0x0,0x0,0x0,0x1000,0x200,0xfc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x200,0x0,0x400,0x400,0x80800,0x1,0x80800,0x200,0x0,0x80800,0x0,0x400,0x80001,0x4,0x0,0x400,0x80,0x8000,0x18001,0xc0,0xc0,0x900,0x900,0x0,0x0,0x0,0x80000,0x200,0x1,0x298001,0x400,0x200,0x18000,0x9c0,0x9c0,0x400,0x200,};
   }

  public InnerParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public InnerParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new InnerParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public InnerParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new InnerParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public InnerParser(InnerParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public void ReInit(InnerParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[57];
    for (int i = 0; i < 57; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 46; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 57; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
